import FavoriteIcon from "@mui/icons-material/Favorite";
import WhatshotIcon from "@mui/icons-material/Whatshot";
import { act, renderHook } from "@testing-library/react";
import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { Enemy, Hero } from "./adventure.types";
import { useCombatManager } from "./useCombatManager";

describe("useCombatManager", () => {
  let mockHero: Hero;
  let mockEnemies: Enemy[];
  let mockSetHero: ReturnType<typeof vi.fn>;
  let mockOnEnemyDefeated: ReturnType<typeof vi.fn>;

  beforeEach(() => {
    vi.clearAllTimers();
    vi.useFakeTimers();

    mockHero = {
      attackDamage: 2,
      regenerationRate: 1,
      maxHealth: 100,
      currentHealth: 100,
      level: 1,
      experience: 0,
      experienceToNextLevel: 100,
      defense: 0,
    };

    mockEnemies = [
      {
        id: "NightBorne",
        name: "Night Borne",
        maxHealth: 10,
        currentHealth: 10,
        attackDamage: 3,
        defense: 0,
        experience: 50,
        bonus: {
          type: "hp",
          amount: 5,
          icon: FavoriteIcon,
          iconColor: "primary" as const,
        },
      },
      {
        id: "Skeleton",
        name: "Skeleton",
        maxHealth: 15,
        currentHealth: 15,
        attackDamage: 4,
        defense: 1,
        experience: 75,
        bonus: {
          type: "attack",
          amount: 1,
          icon: WhatshotIcon,
          iconColor: "error" as const,
        },
      },
    ];

    mockSetHero = vi.fn((update) => {
      if (typeof update === "function") {
        mockHero = update(mockHero);
      } else {
        mockHero = update;
      }
    });

    mockOnEnemyDefeated = vi.fn();
  });

  afterEach(() => {
    vi.clearAllTimers();
    vi.useRealTimers();
  });

  describe("Initialization", () => {
    it("should initialize with first enemy", () => {
      const { result, unmount } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      expect(result.current.currentEnemy).toEqual(mockEnemies[0]);
      expect(result.current.heroState).toBe("idle");
      expect(result.current.enemyState).toBe("idle");
      
      unmount();
    });

    it("should handle empty enemy list", () => {
      const { result, unmount } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: [],
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      expect(result.current.currentEnemy).toBeNull();
      
      unmount();
    });
  });

  describe("Combat - Correct Answer", () => {
    it("should damage enemy on correct answer", () => {
      const { result, unmount } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      const initialEnemyHealth = result.current.currentEnemy!.currentHealth;

      act(() => {
        result.current.performAttack(true);
      });

      expect(result.current.currentEnemy!.currentHealth).toBe(
        initialEnemyHealth - mockHero.attackDamage
      );
      
      unmount();
    });

    it("should damage hero on correct answer (counterattack)", () => {
      const { result, unmount } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        result.current.performAttack(true);
      });

      expect(mockSetHero).toHaveBeenCalled();
      const setHeroCall = mockSetHero.mock.calls[0][0];
      const updatedHero = setHeroCall(mockHero);
      expect(updatedHero.currentHealth).toBe(
        mockHero.currentHealth - mockEnemies[0].attackDamage
      );
      
      unmount();
    });

    it("should set hero to attacking state", () => {
      const { result } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        result.current.performAttack(true);
      });

      expect(result.current.heroState).toBe("attacking");
    });

    it("should reset hero to idle after animation", async () => {
      const { result } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        result.current.performAttack(true);
      });

      expect(result.current.heroState).toBe("attacking");

      act(() => {
        vi.advanceTimersByTime(500);
      });

      expect(result.current.heroState).toBe("idle");
    });

    it("should apply regeneration after attack", () => {
      mockHero.currentHealth = 50;

      const { result } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        result.current.performAttack(true);
      });

      const regenerationCall = mockSetHero.mock.calls.find((call) => {
        const updated = call[0](mockHero);
        return (
          updated.currentHealth >
          mockHero.currentHealth - mockEnemies[0].attackDamage
        );
      });

      expect(regenerationCall).toBeDefined();
    });
  });

  describe("Combat - Wrong Answer", () => {
    it("should apply 1.5x damage on wrong answer", () => {
      const { result } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        result.current.performAttack(false);
      });

      const expectedDamage = mockEnemies[0].attackDamage * 1.5;

      expect(mockSetHero).toHaveBeenCalled();
      const setHeroCall = mockSetHero.mock.calls[0][0];
      const updatedHero = setHeroCall(mockHero);
      expect(updatedHero.currentHealth).toBe(
        mockHero.currentHealth - expectedDamage
      );
    });

    it("should not damage enemy on wrong answer", () => {
      const { result } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      const initialEnemyHealth = result.current.currentEnemy!.currentHealth;

      act(() => {
        result.current.performAttack(false);
      });

      expect(result.current.currentEnemy!.currentHealth).toBe(
        initialEnemyHealth
      );
    });

    it("should keep hero idle on wrong answer", () => {
      const { result } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        result.current.performAttack(false);
      });

      act(() => {
        vi.advanceTimersByTime(1000);
      });

      expect(result.current.heroState).toBe("idle");
    });
  });

  describe("Enemy Defeat", () => {
    it("should trigger defeated state when enemy health reaches 0", () => {
      const { result, unmount } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        let attacks = 0;
        while (result.current.currentEnemy!.currentHealth > 0 && attacks < 20) {
          result.current.performAttack(true);
          attacks++;
        }
      });

      expect(result.current.enemyState).toBe("defeated");
      unmount();
    });

    it("should call onEnemyDefeated callback", async () => {
      const { result, unmount } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        let attacks = 0;
        while (result.current.currentEnemy!.currentHealth > 0 && attacks < 20) {
          result.current.performAttack(true);
          attacks++;
        }
      });

      act(() => {
        vi.advanceTimersByTime(1000);
      });

      expect(mockOnEnemyDefeated).toHaveBeenCalled();
      unmount();
    });

    it("should spawn new enemy after defeat", async () => {
      const { result, unmount } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        let attacks = 0;
        while (result.current.currentEnemy!.currentHealth > 0 && attacks < 20) {
          result.current.performAttack(true);
          attacks++;
        }
      });

      act(() => {
        vi.advanceTimersByTime(1050);
      });

      expect(result.current.currentEnemy).not.toBeNull();
      expect(result.current.currentEnemy!.currentHealth).toBeGreaterThan(0);
      unmount();
    });
  });

  describe("Hero Defeat", () => {
    it("should reset hero when health reaches 0", () => {
      mockHero.currentHealth = 5;

      const { result } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        result.current.performAttack(false);
      });

      act(() => {
        vi.advanceTimersByTime(100);
      });

      const resetCall = mockSetHero.mock.calls.find((call) => {
        const updated = call[0](mockHero);
        return updated.currentHealth === mockHero.maxHealth;
      });

      expect(resetCall).toBeDefined();
    });

    it("should reset enemy to first enemy when hero is defeated", () => {
      mockHero.currentHealth = 5;

      const { result } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        result.current.performAttack(true);
      });

      act(() => {
        while (mockHero.currentHealth > 0) {
          result.current.performAttack(false);
        }
      });

      act(() => {
        vi.advanceTimersByTime(100);
      });

      expect(result.current.currentEnemy?.id).toBe(mockEnemies[0].id);
    });
  });

  describe("Damage Animation", () => {
    it("should show damage animation when enemy attacks", () => {
      const { result } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        result.current.performAttack(true);
      });

      expect(result.current.showDamageAnimation).toBe(true);
    });

    it("should hide damage animation after timeout", async () => {
      const { result } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        result.current.performAttack(true);
      });

      expect(result.current.showDamageAnimation).toBe(true);

      act(() => {
        vi.advanceTimersByTime(1000);
      });

      expect(result.current.showDamageAnimation).toBe(false);
    });

    it("should increment animation key on each attack", () => {
      const { result } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      const initialKey = result.current.damageAnimationKey;

      act(() => {
        result.current.performAttack(true);
      });

      expect(result.current.damageAnimationKey).toBe(initialKey + 1);

      act(() => {
        result.current.performAttack(true);
      });

      expect(result.current.damageAnimationKey).toBe(initialKey + 2);
    });
  });

  describe("Defense Calculation", () => {
    it("should reduce damage based on defense", () => {
      mockHero.defense = 2;

      const { result } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        result.current.performAttack(true);
      });

      const expectedDamage = Math.max(
        0,
        mockEnemies[0].attackDamage - mockHero.defense
      );

      const setHeroCall = mockSetHero.mock.calls[0][0];
      const updatedHero = setHeroCall(mockHero);
      expect(updatedHero.currentHealth).toBe(
        mockHero.currentHealth - expectedDamage
      );
    });

    it("should not allow negative health", () => {
      mockHero.currentHealth = 1;

      const { result } = renderHook(() =>
        useCombatManager({
          hero: mockHero,
          setHero: mockSetHero,
          availableEnemies: mockEnemies,
          onEnemyDefeated: mockOnEnemyDefeated,
        })
      );

      act(() => {
        result.current.performAttack(false);
      });

      const setHeroCall = mockSetHero.mock.calls[0][0];
      const updatedHero = setHeroCall(mockHero);
      expect(updatedHero.currentHealth).toBeGreaterThanOrEqual(0);
    });
  });
});
